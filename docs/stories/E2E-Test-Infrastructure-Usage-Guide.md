# E2E Test Infrastructure Usage Guide

## Overview

This guide provides comprehensive documentation for the new E2E test data infrastructure created to support comprehensive reader progress validation. The infrastructure includes test fixtures, data builders, performance monitoring, and specialized utilities for testing reader progress functionality.

## Table of Contents

1. [Test Fixtures](#test-fixtures)
2. [Test Data Builders](#test-data-builders)
3. [Test Data Management](#test-data-management)
4. [Performance Monitoring](#performance-monitoring)
5. [Progress Restoration Testing](#progress-restoration-testing)
6. [Intersection Observer Testing](#intersection-observer-testing)
7. [Database Seeding](#database-seeding)
8. [Performance Benchmarks](#performance-benchmarks)
9. [Usage Examples](#usage-examples)
10. [Best Practices](#best-practices)

## Test Fixtures

### Location
`tests/fixtures/resources/test-documents.ts`

### Available Fixtures

#### Document Size Categories
- **Small Documents**: Single screen, no scrolling (~200 words)
- **Medium Documents**: 2-3 screens, moderate scrolling (~800 words)
- **Large Documents**: 10+ screens, extensive scrolling (~3000 words)

#### Pre-built Fixtures
```typescript
import {
  smallDocumentFixture,
  mediumDocumentFixture,
  largeDocumentFixture
} from '../../fixtures/resources/test-documents'

// Access by ID
import { testFixtures } from '../../fixtures/resources/test-documents'
const mediumDoc = testFixtures['test-doc-medium-001']
```

### Progress Data Fixtures
```typescript
import { testProgressFixtures } from '../../fixtures/resources/test-documents'

// Various progress states
const progressData = testProgressFixtures // Array of TestProgressData
```

## Test Data Builders

### Location
`tests/builders/test-data-builders.ts`

### Creating Custom Test Resources

```typescript
import {
  TestResourceBuilder,
  TestProgressBuilder,
  TestDataFactory
} from '../../builders/test-data-builders'

// Create a custom document
const customDoc = new TestResourceBuilder()
  .withId('my-test-doc')
  .withTitle('Custom Test Document')
  .withSize('large')
  .withComplexity('complex')
  .withAutoGeneratedContent('large', 'My Topic')
  .build()

// Create custom progress data
const customProgress = new TestProgressBuilder()
  .withUserId('test-user-001')
  .withResourceId('my-test-doc')
  .withScrollPercent(0.75)
  .withLastPosition(0, 600)
  .withReadingTime(15)
  .build()

// Use factory for multiple variations
const sizeVariations = TestDataFactory.createSizeVariationSet('Reader Progress')
```

### Builder Patterns

#### TestSectionBuilder
```typescript
const section = new TestSectionBuilder()
  .withId('section-1')
  .withTitle('Introduction')
  .withContent('Your content here...')
  .withEstimatedReadTime(5)
  .build()
```

#### TestResourceBuilder
```typescript
const resource = new TestResourceBuilder()
  .withId('test-resource')
  .withTitle('Test Resource')
  .withSize('medium')
  .addSection(sectionBuilder)
  .withAutoGeneratedContent('medium', 'Topic')
  .build()
```

#### TestProgressBuilder
```typescript
const progress = new TestProgressBuilder()
  .withUserId('user-123')
  .withResourceId('resource-456')
  .withScrollPercent(0.5)
  .withStatus('in_progress')
  .withRandomTimestamp(3) // 3 days ago
  .build()
```

## Test Data Management

### Location
`tests/utils/test-data/test-data-manager.ts`

### Using the Test Data Manager

```typescript
import {
  testDataManager,
  TestSetup,
  Validator
} from '../../utils/test-data/test-data-manager'

// Get resources by size
const mediumDocs = testDataManager.getResourcesBySize('medium')

// Get progress data
const progressData = testDataManager.getProgressData('test-doc-medium-001')

// Add custom data
testDataManager.addResource(customDoc)
testDataManager.addProgressData('resource-id', customProgressArray)

// Validate data
const validation = Validator.validateAllTestData()
if (!validation.isValid) {
  console.error('Test data validation failed:', validation.errors)
}
```

### E2E Test Setup Utilities

```typescript
import { TestSetup } from '../../utils/test-data/test-data-manager'

// Inject test content into page
await TestSetup.injectTestContent(page, testDocument)

// Wait for progress component
await TestSetup.waitForProgressComponent(page)

// Get current scroll position
const position = await TestSetup.getCurrentScrollPosition(page)

// Scroll to specific percentage
await TestSetup.scrollToPercentage(page, 0.5)

// Simulate reading behavior
await TestSetup.simulateReading(page, 5000, 10) // 5 seconds, 10 steps

// Clear test content
await TestSetup.clearTestContent(page)
```

## Performance Monitoring

### Location
`tests/monitors/performance-monitor.ts`

### Basic Performance Monitoring

```typescript
import { createPerformanceMonitor } from '../../monitors/performance-monitor'

const monitor = createPerformanceMonitor(page)

// Start monitoring
await monitor.startMonitoring({
  intervalMs: 1000,
  maxDuration: 30000,
  includeDetails: true,
  trackLeaks: true
})

// Perform test operations
await TestSetup.simulateReading(page, 10000)

// Stop and get results
const metrics = await monitor.stopMonitoring()
const performanceData = monitor.exportMetrics()

// Validate performance
import { PerformanceValidator } from '../../monitors/performance-monitor'
const validation = PerformanceValidator.validatePerformance(performanceData)
```

### Memory Monitoring

```typescript
import { createMemoryMonitor } from '../../monitors/memory-monitor'

const memoryMonitor = createMemoryMonitor(page, {
  snapshotInterval: 1000,
  monitoringDuration: 20000,
  enableDetailedTracking: true,
  gcTriggerThreshold: 100 // MB
})

// Start monitoring
await memoryMonitor.startMonitoring()

// Perform operations
// ... test operations ...

// Get results
const results = await memoryMonitor.stopMonitoring()
const leakDetection = results.analysis
const memorySummary = results.summary

// Check for leaks
if (leakDetection.hasLeaks) {
  console.warn('Memory leaks detected:', leakDetection.patterns)
}
```

### Performance Benchmarks

```typescript
import { createProgressTrackingBenchmarks } from '../../monitors/performance-benchmarks'

const benchmarks = createProgressTrackingBenchmarks(page)

// Run all benchmarks
const results = await benchmarks.runAllBenchmarks({
  iterations: 10,
  warmupIterations: 3,
  measureMemory: true,
  measureFrameRate: true
})

console.log(`Benchmark score: ${results.summary.overallScore}`)
console.log(`Passed: ${results.summary.passedBenchmarks}/${results.summary.totalBenchmarks}`)
```

## Progress Restoration Testing

### Location
`tests/utils/test-data/progress-restoration-helpers.ts`

### Basic Restoration Testing

```typescript
import { ProgressRestorationHelper } from '../../utils/test-data/progress-restoration-helpers'

// Test single restoration
const result = await ProgressRestorationHelper.testRestorationFromProgress(
  page,
  progressData,
  0.05 // 5% tolerance
)

if (!result.success) {
  console.error('Restoration failed:', result.errors)
}

// Test multiple restorations
const multiResult = await ProgressRestorationHelper.testMultipleRestorations(
  page,
  progressDataArray
)

// Test with reloads
const reloadResult = await ProgressRestorationHelper.testRestorationWithReloads(
  page,
  progressData,
  3 // 3 reloads
)

// Test across different viewports
const viewportResult = await ProgressRestorationHelper.testRestorationAcrossViewports(
  page,
  progressData,
  [
    { width: 375, height: 667, name: 'mobile' },
    { width: 768, height: 1024, name: 'tablet' },
    { width: 1920, height: 1080, name: 'desktop' }
  ]
)
```

### Comprehensive Restoration Testing

```typescript
import { runComprehensiveRestorationTests } from '../../utils/test-data/progress-restoration-helpers'

const testResourceIds = ['test-doc-small-001', 'test-doc-medium-001', 'test-doc-large-001']
const comprehensiveResults = await runComprehensiveRestorationTests(page, testResourceIds)

console.log('Restoration test summary:', comprehensiveResults.summary)
```

## Intersection Observer Testing

### Location
`tests/utils/test-data/intersection-observer-mocks.ts`

### Mock Intersection Observer Setup

```typescript
import {
  createMockIntersectionObserver,
  IntersectionObserverTestScenarios
} from '../../utils/test-data/intersection-observer-mocks'

// Create mock observer
const mockObserver = createMockIntersectionObserver(page, {
  root: '#viewport-container',
  rootMargin: '50px',
  threshold: [0, 0.25, 0.5, 0.75, 1]
})

// Initialize mock
await mockObserver.initialize()

// Simulate intersection events
await mockObserver.simulateElementEntersViewport('.content-section')
await mockObserver.simulatePartialIntersection('.content-section', 0.5)
await mockObserver.simulateElementLeavesViewport('.content-section')

// Simulate scrolling with intersections
await mockObserver.simulateScrollingWithIntersections([
  { scrollY: 0, visibleElements: ['#header'] },
  { scrollY: 500, visibleElements: ['#section-1', '#section-2'] },
  { scrollY: 1000, visibleElements: ['#section-2', '#section-3'] }
])

// Cleanup
await mockObserver.cleanup()
```

### Test Scenarios

```typescript
// Test basic intersection
const basicTest = await IntersectionObserverTestScenarios.testBasicIntersection(
  page,
  '.test-element'
)

// Test scroll-based intersections
const scrollTest = await IntersectionObserverTestScenarios.testScrollBasedIntersection(
  page,
  ['.section-1', '.section-2', '.section-3']
)

// Test threshold behavior
const thresholdTest = await IntersectionObserverTestScenarios.testThresholdIntersection(
  page,
  '.test-element',
  [0.1, 0.5, 0.9]
)
```

## Database Seeding

### Location
`tests/utils/test-data/database-seeding.ts`

### Quick Seeding

```typescript
import { quickSeedForTesting } from '../../utils/test-data/database-seeding'

// Quick seed with default configuration
await quickSeedForTesting()
```

### Advanced Seeding

```typescript
import { createProgressTestSeeder } from '../../utils/test-data/database-seeding'

const seeder = createProgressTestSeeder({
  supabaseUrl: process.env.SUPABASE_URL,
  supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
  cleanupBeforeSeeding: true,
  seedTestData: true,
  seedUserSessions: true
})

// Run seeding
const result = await seeder.seed()

if (!result.success) {
  console.error('Seeding failed:', result.errors)
}

// Verify seeding
const verification = await seeder.verifySeeding()
console.log('Seeding verification:', verification.counts)
```

## Performance Benchmarks

### Location
`tests/monitors/performance-benchmarks.ts`

### Running Benchmarks

```typescript
import { createProgressTrackingBenchmarks } from '../../monitors/performance-benchmarks'

const benchmarks = createProgressTrackingBenchmarks(page)

// Run all benchmarks
const results = await benchmarks.runAllBenchmarks({
  iterations: 10,
  warmupIterations: 3,
  measureMemory: true,
  measureFrameRate: true,
  timeout: 30000
})

// Analyze results
results.results.forEach(result => {
  console.log(`${result.componentName} - ${result.operation}:`)
  console.log(`  Average: ${result.metrics.averageTime}ms`)
  console.log(`  P95: ${result.metrics.p95Time}ms`)
  console.log(`  Passed: ${result.validation.passed}`)
})
```

### Performance Thresholds

```typescript
import { createPerformanceThresholdValidator } from '../../monitors/performance-thresholds'

// Create validator for specific environment
const validator = createPerformanceThresholdValidator('ci')

// Validate performance metrics
const validation = validator.validatePerformance(
  performanceMetrics,
  memoryAnalysis,
  benchmarkResults
)

if (!validation.overallPassed) {
  console.error('Performance validation failed:', validation.summary)
}
```

## Usage Examples

### Complete E2E Test Example

```typescript
import { test, expect } from '@playwright/test'
import {
  testDataManager,
  TestSetup,
  createPerformanceMonitor,
  createMemoryMonitor,
  ProgressRestorationHelper,
  createMockIntersectionObserver
} from '../../utils/test-data/test-data-manager'

test.describe('Reader Progress E2E Tests', () => {
  test('comprehensive progress tracking validation', async ({ page }) => {
    // Setup
    const testDoc = testDataManager.getResource('test-doc-medium-001')
    const progressData = testDataManager.getProgressData('test-doc-medium-001')[0]

    const performanceMonitor = createPerformanceMonitor(page)
    const memoryMonitor = createMemoryMonitor(page)
    const mockObserver = createMockIntersectionObserver(page)

    // Initialize monitoring
    await performanceMonitor.startMonitoring()
    await memoryMonitor.startMonitoring()
    await mockObserver.initialize()

    try {
      // Navigate and test content loading
      await page.goto('/reader/test-doc-medium-001')
      await page.waitForLoadState('networkidle')

      // Inject test content if needed
      if (testDoc) {
        await TestSetup.injectTestContent(page, testDoc)
      }

      // Wait for progress component
      await TestSetup.waitForProgressComponent(page)

      // Test progress restoration
      const restorationResult = await ProgressRestorationHelper.testRestorationFromProgress(
        page,
        progressData
      )
      expect(restorationResult.success).toBe(true)

      // Test scroll performance
      const scrollPerformance = await performanceMonitor.monitorScrollPerformance({
        scrollSteps: 10,
        stepDuration: 500,
        measureFrameRate: true
      })

      // Test intersection observer behavior
      await mockObserver.simulateElementEntersViewport('.content-section')
      await mockObserver.simulateScrollingWithIntersections([
        { scrollY: 0, visibleElements: ['#section-1'] },
        { scrollY: 500, visibleElements: ['#section-1', '#section-2'] }
      ])

    } finally {
      // Cleanup and get results
      const performanceResults = await performanceMonitor.stopMonitoring()
      const memoryResults = await memoryMonitor.stopMonitoring()
      await mockObserver.cleanup()

      // Validate performance
      expect(memoryResults.analysis.leakScore).toBeLessThan(50)
      expect(performanceResults.summary.memoryAnalysis.memoryGrowth).toBeLessThan(50 * 1024 * 1024)
    }
  })
})
```

### Scroll Position Testing

```typescript
import { scrollPositionTestDataGenerators } from '../../fixtures/scroll-positions'

test('scroll position accuracy', async ({ page }) => {
  const resourceId = 'test-doc-medium-001'
  const scrollTestData = scrollPositionTestDataGenerators.generateScrollPositionTestData(resourceId)

  for (const testData of scrollTestData) {
    await page.goto(`/reader/${resourceId}`)
    await page.waitForLoadState('networkidle')

    // Restore to specific position
    await TestSetup.scrollToPercentage(page, testData.scrollPercent)
    await page.waitForTimeout(1000)

    // Verify position
    const actualPosition = await TestSetup.getCurrentScrollPosition(page)
    expect(Math.abs(actualPosition.percent - testData.scrollPercent)).toBeLessThan(0.01)
  }
})
```

## Best Practices

### 1. Test Data Management
- Use the test data manager for consistent test data
- Validate test data before running tests
- Clean up test data after tests complete
- Use appropriate document sizes for test scenarios

### 2. Performance Monitoring
- Always start monitoring before test operations
- Include both performance and memory monitoring
- Use appropriate thresholds for your test environment
- Validate performance results against expected baselines

### 3. Progress Restoration
- Test restoration with various scroll positions
- Include edge cases (0%, 100%, very small changes)
- Test across different viewports and devices
- Validate restoration accuracy within tolerance

### 4. Intersection Observer Testing
- Use mock observers for deterministic testing
- Test various intersection scenarios
- Include threshold and root margin testing
- Clean up mocks after testing

### 5. Database Seeding
- Use cleanup before seeding for consistent state
- Verify seeding results before running tests
- Use appropriate test data for your scenarios
- Consider environment-specific seeding configurations

### 6. Error Handling
- Always include try-finally blocks for cleanup
- Validate test prerequisites before testing
- Handle missing test data gracefully
- Provide meaningful error messages

### 7. Test Organization
- Group related tests together
- Use descriptive test names
- Include test documentation
- Follow consistent patterns across tests

## Environment-Specific Configurations

### Development
```typescript
const validator = createPerformanceThresholdValidator('development')
const memoryMonitor = createMemoryMonitor(page, {
  gcTriggerThreshold: 200 // More lenient for development
})
```

### CI/CD
```typescript
const validator = createPerformanceThresholdValidator('ci')
const benchmarks = createProgressTrackingBenchmarks(page)
await benchmarks.runAllBenchmarks({
  iterations: 5, // Fewer iterations for CI speed
  timeout: 10000
})
```

### Production Testing
```typescript
const validator = createPerformanceThresholdValidator('production')
const memoryMonitor = createMemoryMonitor(page, {
  monitoringDuration: 60000 // Longer monitoring for production
})
```

## Troubleshooting

### Common Issues

1. **Memory API Not Available**
   - Ensure Chrome/Chromium browser
   - Check browser security settings
   - Use alternative metrics if memory API unavailable

2. **Performance Monitoring Timeouts**
   - Increase timeout values for complex tests
   - Check for infinite loops or blocking operations
   - Validate test environment performance

3. **Test Data Validation Failures**
   - Check test data consistency
   - Verify data builder configurations
   - Ensure proper data relationships

4. **Intersection Observer Mock Issues**
   - Ensure proper cleanup between tests
   - Check for conflicting observer implementations
   - Validate mock configuration parameters

### Debug Tools

```typescript
// Enable debug logging
process.env.DEBUG_E2E_TESTS = 'true'

// Export test data for inspection
const testData = testDataManager.exportAllData()

// Get detailed performance metrics
const detailedMetrics = performanceMonitor.exportMetrics()

// Analyze memory patterns
const memoryAnalysis = memoryMonitor.detectMemoryLeaks()
```

## Additional Resources

- [Playwright Documentation](https://playwright.dev/)
- [Performance Testing Best Practices](https://web.dev/performance/)
- [Memory Management in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
- [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

For questions or issues with the test infrastructure, please refer to the source code documentation or contact the development team.