/**
 * Test Data Builders for Reader Progress Testing
 *
 * This file provides builder classes for creating test data with various configurations,
 * allowing for flexible and comprehensive test scenario generation.
 */

import { TestResourceFixture, TestProgressData, TestSection } from '../fixtures/resources/test-documents'

/**
 * Builder for creating TestSection instances
 */
export class TestSectionBuilder {
  private section: Partial<TestSection> = {}

  constructor() {
    this.section = {
      id: '',
      title: '',
      content: '',
      estimatedReadTime: 1
    }
  }

  withId(id: string): TestSectionBuilder {
    this.section.id = id
    return this
  }

  withTitle(title: string): TestSectionBuilder {
    this.section.title = title
    return this
  }

  withContent(content: string): TestSectionBuilder {
    this.section.content = content
    // Auto-calculate read time based on content length
    const wordCount = content.split(/\s+/).length
    this.section.estimatedReadTime = Math.ceil(wordCount / 200) // 200 words per minute average
    return this
  }

  withEstimatedReadTime(minutes: number): TestSectionBuilder {
    this.section.estimatedReadTime = minutes
    return this
  }

  build(): TestSection {
    if (!this.section.id) throw new Error('Section ID is required')
    if (!this.section.title) throw new Error('Section title is required')
    if (!this.section.content) throw new Error('Section content is required')

    return this.section as TestSection
  }
}

/**
 * Builder for creating TestResourceFixture instances
 */
export class TestResourceBuilder {
  private resource: Partial<TestResourceFixture> = {
    sections: []
  }

  constructor() {
    this.resource = {
      id: '',
      title: '',
      content: '',
      sections: [],
      metadata: {
        size: 'medium',
        estimatedReadTime: 0,
        complexity: 'moderate',
        wordCount: 0,
        screenCount: 0
      }
    }
  }

  withId(id: string): TestResourceBuilder {
    this.resource.id = id
    return this
  }

  withTitle(title: string): TestResourceBuilder {
    this.resource.title = title
    return this
  }

  withContent(content: string): TestResourceBuilder {
    this.resource.content = content
    return this
  }

  withSize(size: 'small' | 'medium' | 'large'): TestResourceBuilder {
    if (this.resource.metadata) {
      this.resource.metadata.size = size
    }
    return this
  }

  withComplexity(complexity: 'simple' | 'moderate' | 'complex'): TestResourceBuilder {
    if (this.resource.metadata) {
      this.resource.metadata.complexity = complexity
    }
    return this
  }

  addSection(sectionBuilder: TestSectionBuilder): TestResourceBuilder {
    if (!this.resource.sections) {
      this.resource.sections = []
    }
    this.resource.sections.push(sectionBuilder.build())
    return this
  }

  addSections(sections: TestSection[]): TestResourceBuilder {
    if (!this.resource.sections) {
      this.resource.sections = []
    }
    this.resource.sections.push(...sections)
    return this
  }

  withAutoGeneratedContent(
    size: 'small' | 'medium' | 'large',
    topic: string = 'Test Content'
  ): TestResourceBuilder {
    const generators = {
      small: () => this.generateSmallContent(topic),
      medium: () => this.generateMediumContent(topic),
      large: () => this.generateLargeContent(topic)
    }

    const { content, sections } = generators[size]()
    this.resource.content = content
    this.resource.sections = sections
    this.withSize(size)

    // Auto-calculate metadata
    if (this.resource.metadata) {
      this.resource.metadata.wordCount = content.split(/\s+/).length
      this.resource.metadata.estimatedReadTime = Math.ceil(this.resource.metadata.wordCount / 200)
      this.resource.metadata.screenCount = this.estimateScreenCount(content)
    }

    return this
  }

  private generateSmallContent(topic: string): { content: string; sections: TestSection[] } {
    const sections = [
      new TestSectionBuilder()
        .withId('section-1')
        .withTitle(`Introduction to ${topic}`)
        .withContent(`This is a brief introduction to ${topic}. It contains essential information that fits comfortably on a single screen without requiring scrolling. The content is concise but comprehensive enough for meaningful testing scenarios.`)
        .build(),
      new TestSectionBuilder()
        .withId('section-2')
        .withTitle('Key Points')
        .withContent(`The key points about ${topic} include: first, it provides important functionality for testing; second, it demonstrates proper content structure; third, it validates reading progress tracking.`)
        .build()
    ]

    const content = sections.map(s => `# ${s.title}\n\n${s.content}`).join('\n\n')
    return { content, sections }
  }

  private generateMediumContent(topic: string): { content: string; sections: TestSection[] } {
    const sections = [
      new TestSectionBuilder()
        .withId('section-1')
        .withTitle(`Introduction to ${topic}`)
        .withContent(`This comprehensive guide to ${topic} explores the fundamental concepts and practical applications. ${topic} represents an important area of study that requires careful consideration of various factors and approaches.`)
        .build(),
      new TestSectionBuilder()
        .withId('section-2')
        .withTitle('Core Concepts')
        .withContent(`The core concepts of ${topic} include several key principles that form the foundation of understanding. These concepts are interconnected and build upon each other to create a comprehensive framework for analysis and implementation.`)
        .build(),
      new TestSectionBuilder()
        .withId('section-3')
        .withTitle('Practical Applications')
        .withContent(`In practice, ${topic} can be applied in various contexts. Real-world applications demonstrate the versatility and importance of these concepts in solving complex problems and improving outcomes.`)
        .build(),
      new TestSectionBuilder()
        .withId('section-4')
        .withTitle('Advanced Topics')
        .withContent(`For those seeking deeper understanding, advanced topics in ${topic} offer opportunities for exploration and innovation. These areas push the boundaries of current knowledge and practice.`)
        .build()
    ]

    const content = sections.map(s => `# ${s.title}\n\n${s.content}`).join('\n\n')
    return { content, sections }
  }

  private generateLargeContent(topic: string): { content: string; sections: TestSection[] } {
    const chapters = [
      {
        title: `The Foundation of ${topic}`,
        content: `The study of ${topic} has evolved significantly over time, beginning with early observations and developing into a sophisticated field with numerous applications and implications. This chapter explores the historical context and foundational principles that underpin our modern understanding.`
      },
      {
        title: 'Theoretical Frameworks',
        content: `Various theoretical frameworks have been proposed to explain the phenomena observed in ${topic}. These frameworks provide different lenses through which we can analyze and interpret the complex interactions and patterns that emerge. Understanding these theories is essential for comprehensive analysis.`
      },
      {
        title: 'Methodological Approaches',
        content: `Research in ${topic} employs a variety of methodological approaches, each with its own strengths and limitations. From quantitative analyses to qualitative investigations, researchers must carefully select appropriate methods to address their research questions and objectives.`
      },
      {
        title: 'Empirical Evidence',
        content: `A substantial body of empirical evidence supports many of the claims made about ${topic}. Studies conducted across different contexts and populations have yielded consistent findings that reinforce our understanding and guide future research directions.`
      },
      {
        title: 'Contemporary Issues',
        content: `Contemporary issues in ${topic} reflect both longstanding challenges and emerging concerns. Technological advances, changing societal needs, and new research findings continue to shape the landscape and present both opportunities and obstacles.`
      },
      {
        title: 'Future Directions',
        content: `The future of ${topic} holds exciting possibilities and challenges. Emerging technologies, interdisciplinary collaborations, and evolving theoretical perspectives promise to advance the field in unprecedented ways. Researchers and practitioners must remain adaptable and forward-thinking.`
      }
    ]

    const sections = chapters.map((chapter, index) =>
      new TestSectionBuilder()
        .withId(`section-${index + 1}`)
        .withTitle(chapter.title)
        .withContent(chapter.content)
        .build()
    )

    const content = sections.map(s => `## ${s.title}\n\n${s.content}`).join('\n\n')
    return { content, sections }
  }

  private estimateScreenCount(content: string): number {
    // Rough estimation: average 250 words per screen
    const wordCount = content.split(/\s+/).length
    return Math.ceil(wordCount / 250)
  }

  build(): TestResourceFixture {
    if (!this.resource.id) throw new Error('Resource ID is required')
    if (!this.resource.title) throw new Error('Resource title is required')
    if (!this.resource.content) throw new Error('Resource content is required')
    if (!this.resource.sections || this.resource.sections.length === 0) {
      throw new Error('At least one section is required')
    }

    // Auto-calculate metadata if not provided
    if (this.resource.metadata && this.resource.metadata.estimatedReadTime === 0) {
      this.resource.metadata.wordCount = this.resource.content.split(/\s+/).length
      this.resource.metadata.estimatedReadTime = Math.ceil(this.resource.metadata.wordCount / 200)
      this.resource.metadata.screenCount = this.estimateScreenCount(this.resource.content)
    }

    return this.resource as TestResourceFixture
  }
}

/**
 * Builder for creating TestProgressData instances
 */
export class TestProgressBuilder {
  private progress: Partial<TestProgressData> = {}

  constructor() {
    this.progress = {
      userId: '',
      resourceId: '',
      scrollPercent: 0,
      status: 'not_started',
      timestamp: new Date().toISOString()
    }
  }

  withUserId(userId: string): TestProgressBuilder {
    this.progress.userId = userId
    return this
  }

  withResourceId(resourceId: string): TestProgressBuilder {
    this.progress.resourceId = resourceId
    return this
  }

  withScrollPercent(percent: number): TestProgressBuilder {
    this.progress.scrollPercent = Math.max(0, Math.min(1, percent))
    // Auto-update status based on scroll percentage
    if (percent === 0) {
      this.progress.status = 'not_started'
    } else if (percent >= 1) {
      this.progress.status = 'completed'
    } else {
      this.progress.status = 'in_progress'
    }
    return this
  }

  withStatus(status: 'not_started' | 'in_progress' | 'completed'): TestProgressBuilder {
    this.progress.status = status
    return this
  }

  withTimestamp(timestamp: string): TestProgressBuilder {
    this.progress.timestamp = timestamp
    return this
  }

  withLastPosition(x: number, y: number): TestProgressBuilder {
    this.progress.lastPosition = { x, y }
    return this
  }

  withReadingTime(minutes: number): TestProgressBuilder {
    this.progress.readingTime = minutes
    return this
  }

  withRandomTimestamp(daysAgo: number = 0): TestProgressBuilder {
    const now = new Date()
    const past = new Date(now.getTime() - (daysAgo * 24 * 60 * 60 * 1000))
    const randomTime = new Date(
      past.getTime() + Math.random() * (now.getTime() - past.getTime())
    )
    this.progress.timestamp = randomTime.toISOString()
    return this
  }

  build(): TestProgressData {
    if (!this.progress.userId) throw new Error('User ID is required')
    if (!this.progress.resourceId) throw new Error('Resource ID is required')

    return this.progress as TestProgressData
  }
}

/**
 * Factory functions for common test scenarios
 */
export class TestDataFactory {
  /**
   * Create a set of test resources with different sizes
   */
  static createSizeVariationSet(topic: string = 'Test Topic'): TestResourceFixture[] {
    return [
      new TestResourceBuilder()
        .withId(`test-${topic.toLowerCase().replace(/\s+/g, '-')}-small`)
        .withTitle(`Small ${topic} Document`)
        .withAutoGeneratedContent('small', topic)
        .withComplexity('simple')
        .build(),

      new TestResourceBuilder()
        .withId(`test-${topic.toLowerCase().replace(/\s+/g, '-')}-medium`)
        .withTitle(`Medium ${topic} Document`)
        .withAutoGeneratedContent('medium', topic)
        .withComplexity('moderate')
        .build(),

      new TestResourceBuilder()
        .withId(`test-${topic.toLowerCase().replace(/\s+/g, '-')}-large`)
        .withTitle(`Large ${topic} Document`)
        .withAutoGeneratedContent('large', topic)
        .withComplexity('complex')
        .build()
    ]
  }

  /**
   * Create progress data for different test scenarios
   */
  static createProgressScenarioSet(resourceIds: string[]): TestProgressData[] {
    const userIds = ['user-001', 'user-002', 'user-003']
    const scenarios: TestProgressData[] = []

    userIds.forEach(userId => {
      resourceIds.forEach(resourceId => {
        // Not started
        scenarios.push(
          new TestProgressBuilder()
            .withUserId(userId)
            .withResourceId(resourceId)
            .withScrollPercent(0)
            .withRandomTimestamp(7)
            .build()
        )

        // In progress at 25%
        scenarios.push(
          new TestProgressBuilder()
            .withUserId(userId)
            .withResourceId(resourceId)
            .withScrollPercent(0.25)
            .withLastPosition(0, 200)
            .withReadingTime(3)
            .withRandomTimestamp(5)
            .build()
        )

        // In progress at 75%
        scenarios.push(
          new TestProgressBuilder()
            .withUserId(userId)
            .withResourceId(resourceId)
            .withScrollPercent(0.75)
            .withLastPosition(0, 600)
            .withReadingTime(8)
            .withRandomTimestamp(2)
            .build()
        )

        // Completed
        scenarios.push(
          new TestProgressBuilder()
            .withUserId(userId)
            .withResourceId(resourceId)
            .withScrollPercent(1.0)
            .withStatus('completed')
            .withLastPosition(0, 800)
            .withReadingTime(12)
            .withRandomTimestamp(1)
            .build()
        )
      })
    })

    return scenarios
  }

  /**
   * Create a scroll position test set
   */
  static createScrollPositionTestSet(resourceId: string): TestProgressData[] {
    const positions = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0]
    const userId = 'test-scroll-user'

    return positions.map(percent =>
      new TestProgressBuilder()
        .withUserId(userId)
        .withResourceId(resourceId)
        .withScrollPercent(percent)
        .withLastPosition(0, Math.floor(percent * 1000))
        .withReadingTime(Math.floor(percent * 15))
        .build()
    )
  }
}